---
title: "vig1_overview"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vig1_overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# The problem that package `rvecs` tries to solve

Instead of yielding a single estimate of unknown quantity $\theta$, many modern statistical methods yield a set of random draws
$$
  \theta_1, \theta_2, \dots, \theta_S.
$$
These draws might, for instance, be outcomes from a stochastic simulation, or draws from a Bayesian posterior distribution. Quantity $\theta$ could be a scalar, but it could also be a vector with thousands of elements. 

Statistics calculated for the random draws can be used to characterise quantity $\theta$. For instance, the median $q_{0.5}^{(\theta)}$ obtained from $\theta_1, \theta_2, \dots, \theta_S$ can be used as a point estimate of $\theta$, and the quantiles $q_{0.025}^{(\theta)}$ and $q_{0.975}^{(\theta)}$ can be used as endpoints for a 95\% credible interval.

One advantage of having a set of random draws instead of a single estimate is that the draws can be used to inferences about quantities dervied from $\theta$. If $f$ is some function, then to make inferences about $f(\theta)$, we

1. apply $f$ to each draw of $\theta$, obtaining, $f(\theta_1 ), f(\theta_2), \dots, f(\theta_S)$, and then
2. summarise the $f(\theta_1 ), f(\theta_2), \dots, f(\theta_S)$ using statistics such as quantiles.

Say, for instance, that $\theta = (\theta^{\text{F}}, \theta^{\text{M}})$ was a vector describing divorce rates for females and males, and that we were interested in the ratio between female and male rates, implying that $f \equiv f(x,y) = x/y$. To obtain a point estimate and 95\% credible interval, we would 

1. calculate ratios, $\theta_1^{\text{F}}/\theta_1^{\text{M}}, \theta_2^{\text{F}}/\theta_2^{\text{M}}, \dots, \theta_S^{\text{F}}/\theta_S^{\text{M}}$,
2. calculate  median $q_{0.5}^{(\theta^\text{F}/\theta^{\text{M}})}$, and quantiles $q_{0.025}^{(\theta^\text{F}/\theta^{\text{M}})}$ and $q_{0.975}^{(\theta^\text{F}/\theta^{\text{M}})}$.

In computing terms, to make inferences about $f(\theta)$, we follow a map-reduce strategy. In Step 1, we apply transformations, independently, to each of the draws. In Step 2, we assemble the results from these transformations, to produce an overall summary.

Package **rvec** aims to help with the implementation of these steps. It contains a data structure, called an `rvec`, which holds multiple draws, but which tries to behave as much as possible like an ordinary R vector. Base R or tidyverse code written for ordinary vectors should run, with minimal changes, on rvecs. Computations using rvecs are typically faster, and require less memory, than computations that represent random draws using ordinary vectors. Wherever possible, **rvec** uses functions from package **matrixStats** for internal calculations. The `rvec` class extends the `vctrs` class from package **vctrs**, and, with some minor exceptions, discussed in Section XXX, adopt standard `vctrs` behaviors.








    - Parallel
    - Reduce


# Examples

```{r}
library(rvec)
library(dplyr, warn.conflicts = FALSE)
library(tidyr)
library(ggplot2)
```



## Toy example

```{r}
m <- matrix(1:6, nrow = 3)
x <- rvec(m)
x
```

```{r}
x - 1
```



```{r}
x > 3
```

```{r}
x[c(1, 3)]
```



```{r}
y <- rvec(matrix(c(0.5, 2), nrow = 1))
y
```

```{r}
x * y^2
```

```{r}
draws_mean(x)
```


## Regression

```{r}
reg_post[ , 1:5]
```
```{r}
coef <- rvec(reg_post[c("alpha", "beta"), ])
sd <- rvec(reg_post["sigma", , drop = FALSE])
```

```{r}
X <- cbind(1, 0:10)
yhat <- X %*% coef
yhat
```

```{r}
error <- rnorm_rvec(n = 11, mean = 0, sd = sd)
error
```
```{r}
yrep <- yhat + error
yrep
```





## Divorce rates

```{r}
divorce
```

```{r}
divorce_rv <- divorce %>%
  collapse_to_rvec(draw = "sim", value = rate)
divorce_rv
```


```{r}
divorce_rv %>%
  group_by(time, sex) %>%
  summarise(tdr = 5 * sum(rate))
```


```{r}
divorce_rv %>%
  group_by(time, sex) %>%
  summarise(tdr = 5 * sum(rate)) %>%
  mutate(draws_quantile(tdr))
```

```{r}
divorce_rv %>%
  pivot_wider(names_from = sex, values_from = rate) %>%
  mutate(ratio = Female / Male)
```


```{r, fig.width = 5, fig.height = 5}
divorce_rv %>%
  pivot_wider(names_from = sex, values_from = rate) %>%
  mutate(ratio = Female / Male) %>%
  mutate(draws_quantile(ratio)) %>%
  ggplot(aes(x = age, 
             ymin = `ratio_2.5%`, 
             y = `ratio_50%`,
             ymax = `ratio_97.5%`)) +
  facet_wrap(vars(time), ncol = 1) +
  geom_pointrange(fatten = 1)
```



# Working with rvecs

## Creation

## Manipulation

## Mathematics

## Summarising
   
  
# Design

- vctrs
- matrixStats



# Other packages

## rv

## coda, posterior

## ggdist

?other









